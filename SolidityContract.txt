pragma solidity >=0.7.0 <0.9.0;

contract bluePrintsRepository {
    
    BluePrint[] blueprints; 

    struct BluePrint{
        uint UID;  
        uint256 timestamp;
        address owner;
        bytes32 hashValue;
        address[] authorizedAddresses;
        bytes32[] oldHashes;
        uint256[] oldTimestamps; 
        
    }
    //mapping(UID => BluePrint) oldBlueprintHashes; 

    event NewBlueprint(bool isUnique);

    function uploadNewBlueprintHash(uint UID, bytes32 hashValue, address[] memory authorizedAddresses ) public returns(bool isCertified){ 
        bool isUIDUnique = true;
        for(uint i = 0; i<blueprints.length; i++){
            if(blueprints[i].UID == UID){
                isUIDUnique = false;
            }
        }
        if(isUIDUnique){
            bytes32[] memory oldHashes;
            uint256[] memory oldTimestamps;
            BluePrint memory newBlueprint = BluePrint(UID, block.timestamp, msg.sender, hashValue, authorizedAddresses, oldHashes, oldTimestamps);
            blueprints.push(newBlueprint);
        }

        emit NewBlueprint(isUIDUnique);

        return(isUIDUnique);
    }

    event validateEvent(bool isValid, uint UID, address owner);

    function validateBlueprintHash(bytes32 hashValue) public returns(bool isValid, uint uniqueId, address owner){
        bool isValid = false;
        uint someId;
        address owner;
        for(uint i = 0; i<blueprints.length; i++){
            if(blueprints[i].hashValue == hashValue){
                isValid = true;
                someId = blueprints[i].UID;
                owner = blueprints[i].owner;
                break;
            } 
        }

        emit validateEvent(isValid, someId, owner);
        return(isValid,someId, owner);
    }

    event updateEvent(bool bluePrintUpdated, uint256[] oldTimestamps);

    function updateBlueprint(uint UID, bytes32 hashValue) public returns(bool isUpdated, uint256[] memory oldtimestamp, bytes32[] memory oldHashes){
        bool bluePrintUpdated = false;
        //
        uint256[] memory oldtimestamps;
        bytes32[] memory oldHashses;
        //

        for(uint i = 0; i < blueprints.length; i++){
            if(blueprints[i].UID == UID){
                for(uint j = 0; j < blueprints[i].authorizedAddresses.length; j++){
                    if(blueprints[i].authorizedAddresses[j] == msg.sender || blueprints[i].owner == msg.sender){
                        blueprints[i].oldHashes.push(blueprints[i].hashValue);
                        blueprints[i].oldTimestamps.push(blueprints[i].timestamp);
                        blueprints[i].hashValue = hashValue;
                        blueprints[i].timestamp = block.timestamp;
                        bluePrintUpdated = true;
                        //
                        oldtimestamps = blueprints[i].oldTimestamps;
                        oldHashes = blueprints[i].oldHashes;
                        //
                    }
                }
            }
        }

        emit updateEvent(bluePrintUpdated, oldtimestamps);

        return(bluePrintUpdated, oldtimestamps, oldHashses);
    }
}